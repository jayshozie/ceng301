MIT License
Copyright (c) 2025 Emir Baha Yıldırım
Please see the LICENSE file for more details.

> [!NOTE]
> As we've established, sometimes it may be better to have a data structure
> that is actually less powerful, but optimized to the brim to perform certain
> operations incredibly fast. We'll examine two specialty structures, namely
> **stacks**, and **queues**.

-------------------------------------------------------------------------------

# Stack ADT

A *stack* is an ADT that serves as a collection of elements with two main
operations:
- **push,** which adds an element to the collection, and
- **pop,** which removes the most recently added element.

Additionally, a *peek* operation can, without modifying the stack, return the
value of the last element added.

This order of operation is also known as `Last-In-First-Out`, `LIFO`. The
elements are stored in order of insertion, but we do not think of them as
having indexes. The client can only add/remove/examine the last element added,
a.k.a. the `top` of the stack.

## Where are stacks used?

- **Programming Languages and Compilers:**
    - Method/function calls are placed onto a stack (call = push, return = pop)
    - Compilers use stacks to evaluate expressions.

- **Matching Up Related Pairs of Things:**
    - Find out whether a string is a palindrome
    - Matching tags/curly braces
    - Convert `infix` expressions to `postfix` or `prefix` expressions, and you
    have no idea what this is. If you want to learn, check the footnote[^1].

- **Undo/Redo Feature in Editing Software:**
    - Push for every action.
    - Pop for every `undo` action.

-------------------------------------------------------------------------------

# Implementing Class `Stack`

Since we've already learnt templates, we'll use them.

We need:
- **`Stack<T>`:** constructs a new stack with elements type `T`
- **`push(T value)`:** places given value on top of stack
- **`pop()`:** removes top value from stack and returns it, throws
`EmptyStackException` if stack is empty
- **`peek()`:** returns top value of stack without removing it, throws
`EmptyStackException` if stack is empty
- **`size()`:** returns the number of elements in stack
- **`isEmpty()`:** returns `ture` if stack has no elements

## Example Usage

```cpp
Stack<int> s;
s.push(117);
s.push(-28);
s.push(123); // stack: top - (117) (-28) (123) - bottom
std::cout << s.pop() << std::endl; // Output: 123
```

## Limitations in Implementation

- Don't forget that you shouldn't iterate through a stack like a list.
```cpp
Stack<int> myStack;
...
for (int i = 0; i < myStack.size(); i++) {
    ... myStack.get(i); // not a stack if you can iterate through it
}
```
- You should pull contents out of the stack to view them. A common idiom is
removing each element until the stack is completely empty.
```cpp
...
while (!myStack.isEmpty()) {
    ... myStack.pop();
}
...
```

## Array-Based Stack Implementation

In an array-based stack implementation, we will use an array to store the items
of our stack, but we won't implement a way to get the item by index. As we've
established, we need a `constructor`; `pop()`, and `push()` member functions,
and some additional helper member functions.

```cpp
// StackArray.h
#ifndef _StackArray_H_
#define _StackArray_H_
#include "StackException.h"

template<class T> class StackArray {
private:
    int top;
    int capacity;
    T* items;
public:
    StackArray(int cap = 0); // default constructor
    ~StackArray(); // destructor
    StackArray(const StackArray& rhs); // copy constructor
    StackArray& operator=(const StackArray& rhs); // copy assignment operator
    void push(const T& item);
    T pop();
    T peek() const;
    int size() const;
    bool isEmpty() const;
    bool isFull() const;
}; // definitions
```

### Class `stack_exception` (Applies to Both)

We can use the Standard Library's exceptions, they work just fine, but let's
also cover how to create your own exceptions, and use that example in our
stack.

An exception is a class that returns its object. That's it. In most of the
cases, though, you'll also provide a string to accurately throw an error.
```cpp
// StackException.h
#ifndef _StackException_H_
#define _StackException_H_
#include <sstream>
#include <stdexcept>

class StackException : public std::exception {
private:
    std::string errStr;
public:
    StackException(const std::stringstream& string): errStr(string.str()) {}
    const char* what() const noexcept override { return errStr.c_str(); }
    // In c++, to actually create your own exception class, you have to inherit
    // from std::exception, and after that inheritance, you should create a
    // member function called `what()` with return type `const char*`, and that
    // function should have the properties `const`, `noexcept`, `override`.
    // const, because you don't want the function to be able to change the
    // string provided in the argument, noexcept because this function itself
    // is the exception, it shouldn't cause any exception itself, and override
    // because the when you inherit std::exception, you already have a function
    // called `what()` and you need to override the default one.
};

#endif
```

## Array-Based Stack Implementation Continued

```cpp
template<class T> StackArray<T>::StackArray(int cap)
    : capacity(cap), items(new T[this->capacity]), top(-1)
{}
template<class T> StackArray<T>::~StackArray()
{
    delete[] this->items;
    this->capacity = 0;
    this->top = -1;
}
template<class T> StackArray<T>::StackArray(const StackArray<T>& rhs)
    : capacity(rhs.capacity), items(new T[rhs.capacity]), top(rhs.top)
{
    for(int i = 0; i <= this->top; i++) { this->items[i] = rhs.items[i]; }
}
template<class T> StackArray<T>& StackArray<T>::operator=(const StackArray<T>& rhs)
{
    if (this != &rhs) {
        if (this->capacity != rhs.capacity) {
            delete[] this->items;
            this->capacity = rhs.capacity;
            this->items = new T[this->capacity];
        }
        this->top = rhs.top;
        for (int i = 0; i <= this->top; i++) {
            this->items[i] = rhs.items[i];
        }
    }
    return *this;
}

template<class T> void StackArray<T>::push(const T& item)
{
    if(this->top == this->capacity - 1) {
        std::stringstream errStr;
        errStr << "Stack overflow." << std::endl;
        throw StackException(errStr);
    }
    // increase the value of top by 1, add the item to items[]
    this->items[++this->top] = item;
}

template<class T> T StackArray<T>::pop()
{
    if(this->top == -1) {
        std::stringstream errStr;
        errStr << "Stack underflow." << std::endl;
        throw StackException(errStr);
    }
    return this->items[this->top--];
}

template<class T> T StackArray<T>::peek() const
{
    if(this->top == -1) {
        std::stringstream errStr;
        errStr << "Stack is Empty." << std::endl;
        throw StackException(errStr);
    }
    return this->items[this->top];
}

template<class T> int StackArray<T>::size() const
{
    return this->top + 1;
}

template<class T> bool StackArray<T>::isEmpty() const
{
    return this->top == -1;
}

template<class T> bool StackArray<T>::isFull() const
{
    return this->top == this->capacity - 1;
}

#endif
```

## Linked List-Based Stack Implementation

In a linked-list-based stack implementation, we will use a linked list to store
the items of our stack. As we've established, we need a `constructor`; `pop()`,
and `push()` member functions, and some additional helper member functions.
We'll create a class for the nodes of our list, which will be just like a usual
linked list node. It will only have a value variable, and a next pointer
variable.

```cpp
#ifndef _StackLinked_H_
#define _StackLinked_H_
#include "StackException.h"
#include <iostream>

template<class T> class StackNode {
/*
   A StackNode class for the StackLinked class that uses linked lists to implement
   a stack.
 */
public:
    T value;
    StackNode* next;
    StackNode(const T& value = T(), StackNode* next = nullptr)
        : value(value), next(next)
    {} // default constructor
};

template<class T> class StackLinked {
private:
    StackNode<T>* top;
public:
    StackLinked(); // default constructor
    ~StackLinked(); // destructor
    StackLinked(const StackLinked& rhs); // copy constructor
    StackLinked& operator=(const StackLinked& rhs); // copy assignment
    void push(const T& value);
    T pop();
    T peek() const;
    int size() const;
    bool isEmpty() const;
}; // definitions

template<class T> StackLinked<T>::StackLinked()
    : top(nullptr) {} // default constructor
template<class T> StackLinked<T>::~StackLinked()
{
    while(!this->isEmpty()) { this->pop(); }
}
template<class T> StackLinked<T>::StackLinked(const StackLinked& rhs)
    : top(nullptr)
{ // copy constructor
    if(rhs.top == nullptr) { return; }
    this->top = new StackNode<T>(rhs.top->value);
    StackNode<T>* reader = rhs.top->next;
    StackNode<T>* writer = this->top;
    while(reader) {
        writer->next = new StackNode<T>(reader->value);
        writer = writer->next;
        reader = reader->next;
    }
}
template<class T>
StackLinked<T>& StackLinked<T>::operator=(const StackLinked& rhs)
{
    if(this != &rhs) {
        while(!this->isEmpty()) { this->pop(); }

        // !rhs.top would also work, because nullptr returns false
        if(rhs.top == nullptr) { this->top = nullptr; }
        else {
            // make top new node w/ value rhs.top->value, next = nullptr
            this->top = new StackNode<T>(rhs.top->value);
            StackNode<T>* reader = rhs.top->next; // reader is top's next
            StackNode<T>* writer = this->top; // writer is this' top
            while(reader) { // nullptr returns false
                // writer's next is new node w/ value reader, next nullptr
                writer->next = new StackNode<T>(reader->value);

                writer = writer->next; // traverse
                reader = reader->next; // traverse
            }
        } // rhs != nullptr
    } // if(this != &rhs)
    return *this;
}
template<class T> void StackLinked<T>::push(const T& value)
{
    // create new node
    this->top = new StackNode<T>(value, this->top);
}
template<class T> T StackLinked<T>::pop()
{
    if(isEmpty()) {
        std::stringstream errStr;
        errStr << "StackException: Stack Empty on Pop" << std::endl;
        throw StackException(errStr);
    }
    else { // if not empty
        T retTop = this->top->value; // retTop is top's value
        StackNode<T>* tmp = this->top; // tmp points top
        this->top = this->top->next; // top changed to prev
        delete tmp; // top deleted
        return retTop; // retTop returned
    }
}
template<class T> T StackLinked<T>::peek() const
{
    if(isEmpty()) {
        std::stringstream errStr;
        errStr << "StackException: Stack Empty on Peek" << std::endl;
        throw StackException(errStr);
    }
    else { // if not empty
        return this->top->value; // return top value
    }
}
template<class T> int StackLinked<T>::size() const
{
    StackNode<T>* tmp = this->top;
    if(tmp == nullptr) { return 0; }
    else {
        int retSize = 1;
        while(tmp->next != nullptr) {
            retSize++;
            tmp = tmp->next;
        }
        return retSize;
    }
}
template<class T> bool StackLinked<T>::isEmpty() const
{
    return this->top == nullptr;
}

#endif
```

## Example Application - Reversing the Order of the Stack

Suppose we're creating a video editing program, and we're coding the rendering
part of the program. It will use a stack to manage special effects to a base
clip.
1. **Recording Effects (Push):** As the editor applies effects, each one is
*pushed* onto the `EffectsStack`.
2. **Rendering/Reversing:** To render the final video correctly, the program
needs to execute the effects chronologically from the beginning of the
sequence; however, if you just `pop()` the stack you'll get the effects in
reverse order. Thus, we need to reverse the stack.

-------------------------------------------------------------------------------

### Notes

[^1]: Please see the file [Prefix/Infix/Postfix](./extra-w05.md)
