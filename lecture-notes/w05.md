MIT License
Copyright (c) 2025 Emir Baha Yıldırım
Please see the LICENSE file for more details.

> [!NOTE]
> As we've established, sometimes it may be better to have a data structure
> that is actually less powerful, but optimized to the brim to perform certain
> operations incredibly fast. We'll examine two specialty structures, namely
> **stacks**, and **queues**.

-------------------------------------------------------------------------------

# Stack ADT

A *stack* is an ADT that serves as a collection of elements with two main
operations:
- **push,** which adds an element to the collection, and
- **pop,** which removes the most recently added element.

Additionally, a *peek* operation can, without modifying the stack, return the
value of the last element added.

This order of operation is also known as `Last-In-First-Out`, `LIFO`. The
elements are stored in order of insertion, but we do not think of them as
having indexes. The client can only add/remove/examine the last element added,
a.k.a. the `top` of the stack.

## Where are stacks used?

- **Programming Languages and Compilers:**
    - Method/function calls are placed onto a stack (call = push, return = pop)
    - Compilers use stacks to evaluate expressions.

- **Matching Up Related Pairs of Things:**
    - Find out whether a string is a palindrome
    - Matching tags/curly braces
    - Convert `infix` expressions to `postfix` or `prefix` expressions, and you
    have no idea what this is. If you want to learn, check the footnote[^1].

- **Undo/Redo Feature in Editing Software:**
    - Push for every action.
    - Pop for every `undo` action.

-------------------------------------------------------------------------------

# Implementing Class `Stack`

Since we've already learnt templates, we'll use them.

We need:
- **`Stack<T>`:** constructs a new stack with elements type `T`
- **`push(T value)`:** places given value on top of stack
- **`pop()`:** removes top value from stack and returns it, throws
`EmptyStackException` if stack is empty
- **`peek()`:** returns top value of stack without removing it, throws
`EmptyStackException` if stack is empty
- **`size()`:** returns the number of elements in stack
- **`isEmpty()`:** returns `ture` if stack has no elements

## Example Usage

```cpp
Stack<int> s;
s.push(117);
s.push(-28);
s.push(123); // stack: top - (117) (-28) (123) - bottom
std::cout << s.pop() << std::endl; // Output: 123
```

## Limitations in Implementation

- Don't forget that you shouldn't iterate through a stack like a list.
```cpp
Stack<int> myStack;
...
for (int i = 0; i < myStack.size(); i++) {
    ... myStack.get(i); // not a stack if you can iterate through it
}
```
- You should pull contents out of the stack to view them. A common idiom is
removing each element until the stack is completely empty.
```cpp
...
while (!myStack.isEmpty()) {
    ... myStack.pop();
}
...
```

## Array-Based Stack Implementation

In an array-based stack implementation, we will use an array to store the items
of our stack, but we won't implement a way to get the item by index. As we've
established, we need a `constructor`; `pop()`, and `push()` member functions,
and some additional helper member functions.

<details>
    <summary> StackArray.h </summary>

```cpp
// StackArray.h
#ifndef _StackArray_H_
#define _StackArray_H_
#include "StackException.h"

template<class T> class StackArray {
private:
    int top;
    int capacity;
    T* items;
public:
    StackArray(int cap = 0); // default constructor
    ~StackArray(); // destructor
    StackArray(const StackArray& rhs); // copy constructor
    StackArray& operator=(const StackArray& rhs); // copy assignment operator
    void push(const T& item);
    T pop();
    T peek() const;
    int size() const;
    bool isEmpty() const;
    bool isFull() const;
}; // definitions
```
</details>

### Class `stack_exception` (Applies to Both)

We can use the Standard Library's exceptions, they work just fine, but let's
also cover how to create your own exceptions, and use that example in our
stack.

An exception is a class that returns its object. That's it. In most of the
cases, though, you'll also provide a string to accurately throw an error.

```cpp
// StackException.h
#ifndef _StackException_H_
#define _StackException_H_
#include <sstream>
#include <stdexcept>

class StackException : public std::exception {
private:
    std::string errStr;
public:
    StackException(const std::stringstream& string): errStr(string.str()) {}
    const char* what() const noexcept override { return errStr.c_str(); }
    // In c++, to actually create your own exception class, you have to inherit
    // from std::exception, and after that inheritance, you should create a
    // member function called `what()` with return type `const char*`, and that
    // function should have the properties `const`, `noexcept`, `override`.
    // const, because you don't want the function to be able to change the
    // string provided in the argument, noexcept because this function itself
    // is the exception, it shouldn't cause any exception itself, and override
    // because the when you inherit std::exception, you already have a function
    // called `what()` and you need to override the default one.
};

#endif
```

## Array-Based Stack Implementation Continued

<details>
    <summary> StackArray.h Continued </summary>

```cpp
template<class T> StackArray<T>::StackArray(int cap)
    : capacity(cap), items(new T[this->capacity]), top(-1)
{}
template<class T> StackArray<T>::~StackArray()
{
    delete[] this->items;
    this->capacity = 0;
    this->top = -1;
}
template<class T> StackArray<T>::StackArray(const StackArray<T>& rhs)
    : capacity(rhs.capacity), items(new T[rhs.capacity]), top(rhs.top)
{
    for(int i = 0; i <= this->top; i++) { this->items[i] = rhs.items[i]; }
}
template<class T> StackArray<T>& StackArray<T>::operator=(const StackArray<T>& rhs)
{
    if (this != &rhs) {
        if (this->capacity != rhs.capacity) {
            delete[] this->items;
            this->capacity = rhs.capacity;
            this->items = new T[this->capacity];
        }
        this->top = rhs.top;
        for (int i = 0; i <= this->top; i++) {
            this->items[i] = rhs.items[i];
        }
    }
    return *this;
}

template<class T> void StackArray<T>::push(const T& item)
{
    if(this->top == this->capacity - 1) {
        std::stringstream errStr;
        errStr << "Stack overflow." << std::endl;
        throw StackException(errStr);
    }
    // increase the value of top by 1, add the item to items[]
    this->items[++this->top] = item;
}

template<class T> T StackArray<T>::pop()
{
    if(this->top == -1) {
        std::stringstream errStr;
        errStr << "Stack underflow." << std::endl;
        throw StackException(errStr);
    }
    return this->items[this->top--];
}

template<class T> T StackArray<T>::peek() const
{
    if(this->top == -1) {
        std::stringstream errStr;
        errStr << "Stack is Empty." << std::endl;
        throw StackException(errStr);
    }
    return this->items[this->top];
}

template<class T> int StackArray<T>::size() const
{
    return this->top + 1;
}

template<class T> bool StackArray<T>::isEmpty() const
{
    return this->top == -1;
}

template<class T> bool StackArray<T>::isFull() const
{
    return this->top == this->capacity - 1;
}

#endif
```
</details>

## Linked List-Based Stack Implementation

In a linked-list-based stack implementation, we will use a linked list to store
the items of our stack. As we've established, we need a `constructor`; `pop()`,
and `push()` member functions, and some additional helper member functions.
We'll create a class for the nodes of our list, which will be just like a usual
linked list node. It will only have a value variable, and a next pointer
variable.

<details>
    <summary> StackLinked.h </summary>

```cpp
#ifndef _StackLinked_H_
#define _StackLinked_H_
#include "StackException.h"
#include <iostream>

template<class T> class StackNode {
/*
   A StackNode class for the StackLinked class that uses linked lists to implement
   a stack.
 */
public:
    T value;
    StackNode* next;
    StackNode(const T& value = T(), StackNode* next = nullptr)
        : value(value), next(next)
    {} // default constructor
};

template<class T> class StackLinked {
private:
    StackNode<T>* top;
public:
    StackLinked(); // default constructor
    ~StackLinked(); // destructor
    StackLinked(const StackLinked& rhs); // copy constructor
    StackLinked& operator=(const StackLinked& rhs); // copy assignment
    void push(const T& value);
    T pop();
    T peek() const;
    int size() const;
    bool isEmpty() const;
}; // definitions

template<class T> StackLinked<T>::StackLinked()
    : top(nullptr) {} // default constructor
template<class T> StackLinked<T>::~StackLinked()
{
    while(!this->isEmpty()) { this->pop(); }
}
template<class T> StackLinked<T>::StackLinked(const StackLinked& rhs)
    : top(nullptr)
{ // copy constructor
    if(rhs.top == nullptr) { return; }
    this->top = new StackNode<T>(rhs.top->value);
    StackNode<T>* reader = rhs.top->next;
    StackNode<T>* writer = this->top;
    while(reader) {
        writer->next = new StackNode<T>(reader->value);
        writer = writer->next;
        reader = reader->next;
    }
}
template<class T>
StackLinked<T>& StackLinked<T>::operator=(const StackLinked& rhs)
{
    if(this != &rhs) {
        while(!this->isEmpty()) { this->pop(); }

        // !rhs.top would also work, because nullptr returns false
        if(rhs.top == nullptr) { this->top = nullptr; }
        else {
            // make top new node w/ value rhs.top->value, next = nullptr
            this->top = new StackNode<T>(rhs.top->value);
            StackNode<T>* reader = rhs.top->next; // reader is top's next
            StackNode<T>* writer = this->top; // writer is this' top
            while(reader) { // nullptr returns false
                // writer's next is new node w/ value reader, next nullptr
                writer->next = new StackNode<T>(reader->value);

                writer = writer->next; // traverse
                reader = reader->next; // traverse
            }
        } // rhs != nullptr
    } // if(this != &rhs)
    return *this;
}
template<class T> void StackLinked<T>::push(const T& value)
{
    // create new node
    this->top = new StackNode<T>(value, this->top);
}
template<class T> T StackLinked<T>::pop()
{
    if(isEmpty()) {
        std::stringstream errStr;
        errStr << "StackException: Stack Empty on Pop" << std::endl;
        throw StackException(errStr);
    }
    else { // if not empty
        T retTop = this->top->value; // retTop is top's value
        StackNode<T>* tmp = this->top; // tmp points top
        this->top = this->top->next; // top changed to prev
        delete tmp; // top deleted
        return retTop; // retTop returned
    }
}
template<class T> T StackLinked<T>::peek() const
{
    if(isEmpty()) {
        std::stringstream errStr;
        errStr << "StackException: Stack Empty on Peek" << std::endl;
        throw StackException(errStr);
    }
    else { // if not empty
        return this->top->value; // return top value
    }
}
template<class T> int StackLinked<T>::size() const
{
    StackNode<T>* tmp = this->top;
    if(tmp == nullptr) { return 0; }
    else {
        int retSize = 1;
        while(tmp->next != nullptr) {
            retSize++;
            tmp = tmp->next;
        }
        return retSize;
    }
}
template<class T> bool StackLinked<T>::isEmpty() const
{
    return this->top == nullptr;
}

#endif
```
</details>

## Implementation of Stack Using List ADT

In this case, we'll import the linked list class we've written, and use that
to implement the stack. Our `LinkedList.h` needs some improvements for this to
work the way we want it to.
<details>
    <summary> LinkedList.h </summary>

```cpp
// LinkedList.h
#ifndef _Linked_List_H_
#define _Linked_List_H_
#include <iostream>
#include <sstream>
#include <stdexcept>

template<class T> class ListNode {
public:
    T data; // Data part of the node
    ListNode<T>* next; // Pointer to the next node
    ListNode<T>(T value): data(value), next(nullptr) {} // Constructor for nodes
    ListNode<T>(T value, ListNode<T>* ptr)
        : data(value), next(ptr) {} // Constructor with next pointer
};

template<class T> class LinkedList {
private:
    ListNode<T>* head; // Pointer to the first node in the list
    int length; // Current number of elements in the list
public:
    LinkedList(): head(nullptr), length(0) {} // Constructor
    ~LinkedList(); // Destructor
    LinkedList(const LinkedList& rhs); // Copy Constructor
    LinkedList& operator=(const LinkedList& rhs); // Copy Assignment Operator
    void add(T value, int index = -1);
    int lookup_value(T value) const;
    T lookup_index(int index) const;
    void set(T value, int index);
    void remove_value(T value);
    void remove_index(int index);
    int size() const;
    void print() const;
    bool isEmpty() const;
};

template<class T> LinkedList<T>::~LinkedList() // Destructor
{
    ListNode<T>* current = this->head;
    while(current != nullptr) { // Traverse the list and delete nodes
        ListNode<T>* nextNode = current->next; // Store the next node
        delete current; // Delete the current node
        current = nextNode; // Move to the next node
    }
    // After this, head is automatically cleaned up as it's a pointer
}
template<class T> LinkedList<T>::LinkedList(const LinkedList<T>& rhs)
{ // Copy constructor
    this->head = nullptr; // Start with an empty list
    this->length = 0; // Start with size 0
    ListNode<T>* current = rhs.head; // Pointer to traverse the original list
    while(current != nullptr) { // Traverse the rhs list
        this->add(current->data); // Add each element to the new list
        current = current->next;
    }
}
template<class T>
LinkedList<T>& LinkedList<T>::operator=(const LinkedList<T>& rhs)
{
    if(this != &rhs) { // Self-assignment check
        // Clear the current list
        ListNode<T>* current = this->head;
        while(current != nullptr) {
            ListNode<T>* nextNode = current->next;
            delete current;
            current = nextNode;
        }
        this->head = nullptr;
        this->length = 0;
        // Copy elements from rhs
        current = rhs.head;
        while(current != nullptr) {
            this->add(current->data);
            current = current->next;
        }
    }
    return *this; // Return the current object
}
template<class T> void LinkedList<T>::add(T value, int index)
{ // Add an element at a specific index, we'll use the second constructor
    if(index == -1) { // default value to append
        index = this->length;
    }
    if(index < 0 || index > this->length) { // error handling
        std::stringstream errStr;
        errStr << "Error: " << index << " is out of bounds: " << "[0, "
               << this->length << "]" << std::endl;
        throw std::out_of_range(errStr.str()); // Error handling
    }
    // if (this->length == 0) {
    //     this->head = new ListNode<T>(value, this->head);
    // }

    // insertion logic
    if(index == 0) { // insert at head
        this->head = new ListNode<T>(value, this->head);
    }
    else {
        ListNode<T>* current = this->head;
        for(int i = 0; i < index - 1; i++) { current = current->next; }
        ListNode<T>* newNode = new ListNode<T>(value, current->next);
        current->next = newNode;
    }
    this->length++;
}
template<class T> int LinkedList<T>::lookup_value(T value) const
{
    ListNode<T>* current = this->head;
    int i = 0;
    while(current != nullptr) {
        if(value == current->data) { return i; }
        else {
            current = current->next;
            i++; // this case doesn't need a return val
        }
    }
    std::stringstream errStr;
    errStr << "Error: " << value << " is not in the list." << std::endl;
    throw std::invalid_argument(errStr.str());
}
template<class T> T LinkedList<T>::lookup_index(int index) const
{ // Get the element at a specific index
    // get func via index logic
    if(index == -1) {
        index = this->length - 1;
    }
    if(index < 0 || index >= this->length) { // Check for valid index
        std::stringstream errStr;
        errStr << "Error: Lookup index " << index
               << " is out of bounds. Valid range: " << "[0, "
               << this->length - 1 << "]" << std::endl;
        throw std::out_of_range(errStr.str()); // Error handling
    }
    ListNode<T>* current = this->head;
    for(int i = 0; i < index; i++) { // Traverse to the index
        current = current->next;
    }
    return current->data; // Return the data at the given index
}
template<class T> void LinkedList<T>::set(T value, int index)
{ // Set the element at a specific index
    if(index == -1) {
        index = this->length - 1;
    }
    if(index < 0 || index >= this->length) { // Check for valid index
        std::stringstream errStr;
        errStr << "Error: Set index " << index
               << " is out of bounds. Valid range: " << "[0, "
               << this->length - 1 << "]" << std::endl;
        throw std::out_of_range(errStr.str()); // Error handling
    }
    ListNode<T>* current = this->head;
    for(int i = 0; i < index; i++) { // Traverse to
        current = current->next;
    }
    current->data = value; // Set the data at the given index
}
template<class T> void LinkedList<T>::remove_value(T value)
{
    int index = this->lookup_value(value);
    this->remove_index(index);
}
template<class T> void LinkedList<T>::remove_index(int index)
{ // Remove the element at a specific index
    if(index == -1) {
        index = this->length - 1;
    }
    if(index < 0 || index >= this->length) { // Check for valid index
        std::stringstream errStr;
        errStr << "Error: Removal index " << index
               << " is out of bounds. Valid range: " << "[0, "
               << this->length - 1 << "]" << std::endl;
        throw std::out_of_range(errStr.str()); // Error handling
    }
    if(index == 0) { // Remove the head
        ListNode<T>* temp = this->head;
        this->head = head->next;
        delete temp;
    }
    else {
        ListNode<T>* current = this->head;
        for(int i = 0; i < index - 1; i++) { current = current->next; }
        ListNode<T>* temp = current->next;
        current->next = temp->next; // Bypass the node to be removed
        delete temp;
    }
    this->length--; // Decrease the size
}
template<class T> int LinkedList<T>::size() const
{ // Get the current size of the list
    return this->length; // Return the number of elements
}
template<class T> void LinkedList<T>::print() const
{ // Print the contents of the list
    ListNode<T>* current = this->head;
    while(current != nullptr) { // Traverse through the list
        std::cout << current->data << " "; // Print each element
        current = current->next;
    }
    std::cout << std::endl; // New line after printing all elements
}
template<class T> bool LinkedList<T>::isEmpty() const
{
    return this->length == 0;
}
```
</details>

Now, let's implement `StackListADT.h`.

<details>
    <summary> StackListADT.h </summary>

```cpp
#ifndef _StackListADT_H_
#define _StackListADT_H_
#include "LinkedList.h"
#include "StackException.h"

template<class T> class StackListADT {
private:
    LinkedList<T> list;
public:
    void push(const T& item);
    T& pop();
    T& peek() const;
    bool isEmpty() const;
};

template<class T> void StackListADT<T>::push(const T& item)
{
    this->list.add(item);
}
template<class T> T& StackListADT<T>::pop()
{
    this->list.lookup_index(-1);
    this->list.remove_index(-1);
}
template<class T> T& StackListADT<T>::peek() const
{
    this->list.lookup_index(-1);
}
template<class T> bool StackListADT<T>::isEmpty() const
{
    return this->list.isEmpty();
}

#endif
```
</details>

## Example Application - Reversing the Order of the Stack

Suppose we're creating a video editing program, and we're coding the rendering
part of the program. It will use a stack to manage special effects to a base
clip.
1. **Recording Effects (Push):** As the editor applies effects, each one is
*pushed* onto the `EffectsStack`.
2. **Rendering/Reversing:** To render the final video correctly, the program
needs to execute the effects chronologically from the beginning of the
sequence; however, if you just `pop()` the stack you'll get the effects in
reverse order. Thus, we need to reverse the stack.

<details>
    <summary> Solution </summary>

```cpp
template<class T> void StackLinked<T>::reverse()
{
    StackLinked<T> backup;
    while(!this->isEmpty()) {
        try {
            backup.push(this->pop());
        }
        catch(StackException e) {
            break;
        }
    }
    *this = backup;
}
```
</details>

-------------------------------------------------------------------------------

# Delimiter Matching - Example Application

We'll write a program that checks whether the parentheses in a mathematical
expression is balanced. For example, let's say you have
`(w*(x+z)/z-(p/(r-q)))`

- **Rules & Regulations:**
    - The expression may have several different types of delimiters, for
    example, braces (`{}`), brackets (`[]`), parentheses (`()`).
    - Each opening, a.k.a. left, delimiter must be matched by a closing, a.k.a.
    right, delimiter.
    - A delimiter that opens the last must be closed by a matching delimiter
    first. For example `[a*(b+c)+d]` is wrong and should raise an error.

- **Algorithm:**
1. Read characters one-by-one.
2. Whenever you see a left delimiter, push it to the stack.
3. Whenever you see a right delimiter, pop from stack and match, i.e. check
whether they're the same type.
4. If they don't match, raise mismatch error.
5. Expression is unbalanced:
    - if the stack is empty when you try to match a closing delimiter, or
    - if the stack is non-empty after you reach to the end of the expression.
    Otherwise, it's balanced.

<details>
    <summary> Solution </summary>

```cpp
// TODO: IMPLEMENT
```
</details>

-------------------------------------------------------------------------------

# Evaluation of Postfix Expressions - Example Application

-------------------------------------------------------------------------------

### Notes

[^1]: Please see the file [Prefix/Infix/Postfix](./extra-w05.md)
