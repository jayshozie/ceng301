MIT License
Copyright (c) 2025 Emir Baha Yıldırım
Please see the LICENSE file for more details.

> [!NOTE]
> Now, we start working with actual data structures.

-------------------------------------------------------------------------------

# Definitions

## Data Structure

A data structure is a particular way of organizing and storing data in a
computer so that it can be accessed and modified efficiently. Different data
structures are suited to different kinds of applications, and some are highly
specialized to specific tasks. Common data structures include arrays, linked
lists, stacks, queues, trees, hash tables, and graphs.

## Abstract Data Type (ADT)

An abstract data type (ADT) is a mathematical model for a certain class of data
structures that have similar behavior. It is a specification of:
- **The Data:** The collection of data elements.
- **The Operations:** The set of functions that can be performed on that data
(e.g., `insert`, `remove`, `search`).

- **The Core of the Concept:**
    > **An ADT defines *what* a collectionof data does, not *how* it does it.**
    - It is an **interface** that specifies behavior without revealing the
    underlying implementation details.
    - **Example:** A **List** is an **ADT**. You know you can add or remove
    elements.
    - **Constrast:** A **Linked List** or an **Array** are the concrete **Data
    Structures** used to *implement* the List ADT.

So, even if we don't know exactly how an ADT is implemented, we just need to
understand the idea of the collection and what operations it can perform. We
use data structures to provide a concrete, physical implementation of an ADT.

-------------------------------------------------------------------------------

# List ADT

<a href="../slides/w04.pdf">
    <img
        src="./images/list-adt-1.png"
        alt=""
        style="width:50%;
        height:auto;">
</a>

- A **List** is a collection storing an ordered sequence of elements.
    - Each element is accessible by a 0-based index.
    - A list has a size, number of elements that have been added.
    - Elements can be added to the front, back, or to a specific index.


<a href="../slides/w04.pdf">
    <img
        src="./images/list-adt-2.png"
        alt=""
        style="width:50%;
        height:auto;">
</a>

- *Supported Operations:*
    - `get(index)`: returns the item at the given index
    - `set(value, index)`: sets the item at the given index to the given value
    - `add(value)`: adds the given item to the end of the list
    - `add(value, index)`: insert the given item at the given index maintaining
    order
    - `remove(index)`: removes the item at the given index maintaining order
    - `size()`: returns the number of elements in the list
    - `print()`: prints the contents of the list

## List Implementations

<a href="../slides/w04.pdf">
    <img
        src="./images/array-list-1.png"
        alt=""
        style="width:50%;
        height:auto;">
</a>

- **Array List:**
    - Uses a dynamic array to store elements.
    - Provides fast access to elements via indexing.
    - Insertion and deletion can be slow due to shifting elements.
    - Resizing the array may be necessary when it reaches capacity.

<a href="../slides/w04.pdf">
    <img
        src="./images/linked-list-1.png"
        alt=""
        style="width:50%;
        height:auto;">
</a>

- **Linked List:**
    - Consists of nodes where each node contains data and a pointer/reference
    to the next node.
    - Allows for efficient insertions and deletions.
    - Accessing elements requires traversal from the head node.
    - Uses more memory due to storing pointers/references, but avoids resizing.

### Implementing `ArrayList`

<!-- I'll explain every method in it's respective block. -->

<details>
    <summary> `ArrayList` with Error Handling and Explanations of Each Method in the Class </summary>

```cpp
#include <stdexcept>

class ArrayList {
private:
    int* arr;        // Pointer to the dynamic array
    int length;      // Current number of elements in the list
public:
    ArrayList() : length(0) { // Constructor
        arr = new int[0]; // Initialize an empty dynamic array
    }
    ~ArrayList() { // Destructor
        delete[] arr; // Clean up the dynamic array
    }
    // Don't forget, we're not keeping track of a capacity, this is dynamic.
    void add(int value) { // Add an element to the end of the list
        int newLength = length + 1; // New length after adding an element
        int* newArr = new int[newLength]; // Create a new array with increased size
        for (int i = 0; i < length; i++) { // Copy existing elements to the new array
            newArr[i] = arr[i];
        }
        newArr[length] = value; // Add the new element at the end
        delete[] arr; // Delete the old array
        arr = newArr; // Point to the new array
        length++; // Increase the size
    }
    // Overload the add method to insert at a specific index
    void add(int value, int index) { // Add an element at a specific index
        if (index < 0 || index > length) { // Check for valid index
            throw std::out_of_range("Index out of bounds"); // Error handling
        }
        int newLength = length + 1; // New length after adding an element
        int* newArr = new int[newLength]; // Create a new array with increased size
        for (int i = 0; i < index; i++) { // Copy elements before the index
            newArr[i] = arr[i];
        }
        newArr[index] = value; // Insert the new element at the specified index
        for (int i = index; i < length; i++) { // Copy remaining elements
            newArr[i + 1] = arr[i];
        }
        delete[] arr; // Delete the old array
        arr = newArr; // Point to the new array
        length++; // Increase the size
    }
    int get(int index) { // Get the element at a specific index
        if (index < 0 || index >= length) { // Check for valid index
            throw std::out_of_range("Index out of bounds"); // Error handling
        }
        return arr[index]; // Return the element at the given index
    }
    void set(int value, int index) { // Set the element at a specific index
        if (index < 0 || index >= length) { // Check for valid index
            throw std::out_of_range("Index out of bounds"); // Error handling
        }
        arr[index] = value; // Set the element at the given index
    }
    void remove(int index) { // Remove the element at a specific index
        if (index < 0 || index >= length) { // Check for valid index
            throw std::out_of_range("Index out of bounds"); // Error handling
        }
        for (int i = index; i < length - 1; i++) { // Shift elements to the left
            arr[i] = arr[i + 1];
        }
        length--; // Decrease the size
    }
    int size() { // Get the current size of the list
        return length; // Return the number of elements
    }
    void print() { // Print the contents of the list
        for (int i = 0; i < length; i++) { // Iterate through the elements
            std::cout << arr[i] << " "; // Print each element
        }
        std::cout << std::endl; // New line after printing all elements
    }
}
```

We can test our class with the following `main`.

```cpp
int main()
{
    // Test the ArrayList class
    ArrayList list;
    list.add(10);
    list.add(20);
    list.add(30, 1); // Insert 30 at index 1 - should be [10, 30, 20]
    list.print(); // Expected output: 10 30 20
    list.set(25, 2); // Set index 2 to 25 - should be [10, 30, 25]
    list.print(); // Expected output: 10 30 25
    list.remove(1); // Remove index 1 - should be [10, 25
    list.print(); // Expected output: 10 25
    std::cout << "Element at index 0: " << list.get(0) << std::endl; // Expected output: 10
    std::cout << "Size of list: " << list.size() << std::endl; // Expected output: 2
}
```

Output should be the following:
```
10 30 20
10 30 25
10 25
Element at index 0: 10
Size of list: 2
```
</details>
