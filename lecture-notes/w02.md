MIT License
Copyright (c) 2025 Emir Baha Yıldırım
Please see the LICENSE file for more details.

-------------------------------------------------------------------------------

# C++ Overview

## C++ Techniques

Relevant techniques include:
1. C++ classes, with *private* and *public* members.
2. Function and operator name *overloading* to give "natural" function calls.
3. *Templates* to allow the same code to be used on a variate of different data types.
4. A clean *built-in I/O interface*, which itself involves overloading the input and output operators.
Learning these techniques is much of what C++ is about.[^1]

-------------------------------------------------------------------------------

# Constructors

A *constructor* is a method that executes when an object of a class is declared
and sets the initial state of the new object. A constructor has
- the same name with the class,
- no return type,
- zero or more parameters (the constructor without an argument is called the
default constructor).

There may be more than one constructor defined for a class. Although it has a
more general meaning, this is called overloading.

If no constructor is explicitly defined, one that initializes the data members
using language defaultls is automatically generated.

## Same Example from W01.md

```cpp
// IntCell.h
// A class for simulating an integer memory cell

class IntCell
{
public:
    IntCell() {
        storedValue = 0
    }
    IntCell(int initialValue) {
        storedValue = initialValue
    }

    int read() {
        return storedValue;
    }
    void write(int x) {
        storedValue = x;
    }
private:
    int storedValue;
}
```

Let's try to use only a single constructor for the same job, so that it looks
less cluttered.
```cpp
class IntCell
{
public:
    IntCell(int initialValue = 0) : storedValue(initialValue)
    {
        // body of the constructor
    }
}
```
This is called a *member initializer list*. It's how you initialize the
data members (like `storedValue`) of a class **before** the body of the
constructor (`{}`) begins executing.

After the constructor's parameter list (`int initialValue = 0`), you put a
colon `:`. Then, for each member you want to initialize, you write the member's
name followed by parantheses containing the value you want to initialize it
with. In this case, `storedValue(initialValue)` means initialize the
`storedValue` meber with the value passed in `initialValue`. And yes, this is
not explained in the slides. You can learn more about them at
[cppreference.com](https://en.cppreference.com/w/cpp/language/initializer_list.html)

OK, now that we've gone from two constructors to one, let's continue with the
destructors.

-------------------------------------------------------------------------------

# Destructors

A *destructor* is the complement of a *constructor*. It performs termination
housekeeping before the system reclaims the object's memory. An **automatic
default destructor** is added to yourr class if no other destructor is defined.
The only action of the automatic default destructor is to call the default
destructor of all member objects.

## Automatic Default Destructor

A destructor should never be called directly, because it is called
automatically when an object goes out of scope. In other words, it's
automatically called when the object's memory is being reclaimed by the system:
- If the object is on the stack, when the function returns
- If the object is on the heap, when **delete** is used

## Custom Destructors

To add custom behavior to the end-of-life of the function, a custom destructor
can be defined. A custom destructor is a member function, just like a custom
constructor. It's name starts with a tilde (`~`) followed by the class name:
- `~IntCell();`
- `~Cube();`
It can't recieve no parameters, and can't return any values. You can only have
a single destructor per class.

A custom destructor is essential when an object allocates an external resource
tnhat must be closed or freed when the object is destroyed. Examples:
- Heap memory
- Open files

### Example

```cpp
class IntCell
{
public:
    IntCell(int initialValue=0) {
        storedValue = new int(initialValue);
    }
    ~IntCell() {
        delete storedValue;
    }
    
    int read() {
        return *storedValue;
    }
    void write(int x) {
        *storedValuet = x;
    }
private:
    int *storedValue;
}
```

-------------------------------------------------------------------------------

# Separation of Interface and Implementation

Large-scale projects put the interface and implementation of classes in
different files. For small-scale projects it may not matter.

- ***Header File:*** The *header file* contains the interface of a class.
Usually ends with `.h`.

- ***Source Code File:*** The *source code file* contains the implementation of
a class. Usually ends with `.cpp`. `.cpp` file includes the `.h` file with the
***preprocessor*** command `#include`.

## Example

### Header File

`IntCell` class interface in `IntCell.h`:
```cpp
// IntCell.h

#ifndef _IntCell_H_  // include guard, prevents multiple inclusions. stands for "if not defined"
#define _IntCell_H_  // define the macro _IntCell_H_,
// macro means a name replacement by the preprocessor before compilation
// if this file is included again, the code between #ifndef and #endif is skipped.
// the reason the macro starts with _ and ends with _H_ is to reduce the chance of name conflicts.
// it's just a convention, you can use any name you want. e.g. `intcellheader`
// but it's better to follow conventions.

// A class for simulating an integer memory cell
class IntCell
{
public:
    IntCell(int initialValue=0);
    int read() const;
    void write(int x);
private:
    int storedValue;
};
#endif
```

### Implementation File

`IntCell` class implementation in `IntCell.cpp`:
```cpp
// IntCell.cpp
#include <iostream>
#include "IntCell.h"

// construct the IntCell with initialValue
IntCell::IntCell(int initialValue) : storedValue(initialValue) {};

// return the stored value
int IntCell::read() const {
    return storedValue;
}

// store x
void IntCell::write(int x) {
    storedValue = x;
}
```
<details>
    <summary> What the hell `const` is doing there? </summary>

The reason we use the keyword `const` after the parameter list (but before
the body) of a member function is to signify that the function will not
modify the state of the object it is called on. It's technically not
necessary, but it ensures that the object's state cannot be modified.
For example, if you tried to write `storedValue = 99` inside the body of a
`const` function, the compiler would immediately produce an error. It's a
key safety measure, since `read()` is designed only to retrieve a value, using
`const` prevents accidental modifications to the cell's value.

Don't confuse this with `const int IntCell:read() { ... }`, because this
does not do the same job. `const` modifies the return type `int`. Meaning
that the value returned by the function cannot be modified by the caller.
The `const` keyword makes the stuff that comes *after* the keyword, not an
entire block.

So, although we are not actually modifying the state of the object inside the
method `read()`, it is good practice to add the keyword `const` anyway.
</details>

### A Client Program

A program that uses `IntCell` in file `TestIntCell.cpp`:
```cpp
// TestIntCell.cpp
#include <iostream>
#include "IntCell.h"

int main()
{
    IntCell m; // or IntCell m(0);

    m.write(5);
    std::cout << "Cell content: " << m.read() << std::endl;
}
```

-------------------------------------------------------------------------------

# Function Overloading

A function overload is not a single function. It's multiple function with the
same name, but different parameters. Overloaded functions should perform
similar tasks to avoid confusion. Function to square `int`s and function to
square `float`s can have the same name.
```cpp
int square(int x) { return x*x; }
float square(float x) { return x*x; }
```
Compiler chooses which function to use based on the actual given parameter
types:
```cpp
square(4);    // calls the integer version
square(4.0f); // calls the float version
```
Functions that only differ by return type cannot be overloaded:
```cpp
int square(int x) { ... };
float square(int x) { ... };
```
<details>
    <summary> Output of the Above Program </summary>

```bash
❯ test
Compiling...
testBench.cpp:5:7: error: ambiguating new declaration of ‘float square(int)’
    5 | float square(int x) { return x*x; };
      |       ^~~~~~
testBench.cpp:4:5: note: old declaration ‘int square(int)’
    4 | int square(int x) { return x*x; }
      |     ^~~~~~
```
We get a compile error even without calling one of the functions.
</details>

## Overloaded Operators

An operator with more than one meaning is said to be overloaded.
```cpp
2 + 3
3.1 + 3.2
// + is an overloaded operator because it work with more than a single data type
```
To enable a particular operator to operate correctly on different instances of
a class, we may define a new meaning for the operator. Thus, we may overload
it.

## Operator Overloading

Operator overloading allows us to use existing operators for user-defined
classes. The following operators can be overloaded:
```
~     !     =      <      >     new    delete
+     -     *      /      %     ^      &     |
+=    -=    *=     /=     %=    ^=     &=    |=
<<    >>    >>=    <<=    ==    !=     <=    >=
&&    ||    ++     --     ,     ->*    ->    ()    []
```

-------------------------------------------------------------------------------

### Notes

#### Footnote 1

Not exactly. I believe this statement is incomplete, because C++ is not
just about classes or overloading. It's more about system programming,
performance, and zero-overhead abstraction. By zero-overhead abstraction we
mean, you can use high-level, elegant features (like classes and templates)
**without sacrificing performance or control** of low-level languages like C.
C++ is a multi-paradigm language, meaning that it's not just an Object-Oriented
language. It fully supports at least four major programming paradigms:
- Procedural Programming (just like C, and the way you've learned to write up
until this point)
- Object-Orient Programming (the way you're learning right now, using classes
and inheritance)
- Generic Programming (using templates and the Standard Template Library, STL)
- Functional Programming (with features like lambda, which you should learn how
to use)

C++ allows us to implement complex algorithms and data structures in a way that
is closest to the machine, letting us analyze their true time and space
complexity without language overhead. Features like pointers give us precise
control over memory allocation, which is incredibly important to building
efficient data structures like graphs and hash tables from scratch. So, saying
that C++ is just about classes or overloading absurdly underestimates the power
of C++. Thank you for listening my TED Talk.

[^1]: Please see [Footnote 1](#footnote-1)
