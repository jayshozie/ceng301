MIT License
Copyright (c) 2025 Emir Baha Yıldırım
Please see the LICENSE file for more details.

-------------------------------------------------------------------------------

# Queue ADT

A queue is similar to a stack; however, it's backwards. A queue retrieves
elements in the order they were added.
- First-In, First-Out (FIFO)
- Elements are stored in order of insertion, but don't have indices.
- Client can only add to the end of the queue, and can only examine/remove the
front of the queue.

- **Main Operations:**
    - **Enqueue:** Add an element to the back of the queue.
    - **Dequeue:** Remove the front element.
    - **Peek:** Examine the front element.

- **Real-World Examples**
    - People on an escalator: first-in, first-out.
    - Cars at a gas station: first-in, first-out.
    - Line of customers waiting for service at a bank.

- **Computer Science Examples**
    - Serving requests on a single shared resource:
        - Printer: queue print jobs to send to the printer
        - CPU Task Scheduling: queue of programs/processes to be run
        - Network: queue of network data packets to send

    - Sophisticated algorithms:
        - Searching in trees, graphs, e.g. BFS, web crawling.

| Operation          | Explanation                                                                                             |
|:-------------------|--------------------------------------------------------------------------------------------------------:|
| enqueue(**value**) | places given value at the back of queue                                                                 |
| dequeue()          | remove value from front of queue and returns it; throws a `NoSuchElementException` if queue is empty    |
| peek()             | returns front value from queue without removing it; throws a `NoSuchElementException` if queue is empty |
| size()             | returns number of elements in queue                                                                     |
| isEmpty()          | returns `true` if queue has no elements                                                                 |

- **Example Usage:**
```cpp
Queue<int> q;
q.enqueue(42);
q.enqueue(-3);
q.enqueue(17);            // front [42, -3, 17] back
std::cout << q.dequeue(); // Output: 42
```

## Queue Processing Styles

As with stacks, we must pull contents out of the queue to view them,
```cpp
while(!q.isEmpty()) {
    // do something with q.dequeue();
}
```
which consequently destroys the queue, but we may actually want that.

Here's another style,
```cpp
int n = q.size();
for(int i = 0; i < n; i++) {
    // do something with q.dequeue();
    // including possibly re-adding it to the queue
}
```
which also destroys it, but, again, we may actually want that.
Why did we 
