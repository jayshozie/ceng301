MIT License
Copyright (c) 2025 Emir Baha Yıldırım
Please see the LICENSE file for more details.

-------------------------------------------------------------------------------

# Queue ADT

A queue is similar to a stack; however, it's backwards. A queue retrieves
elements in the order they were added.
- First-In, First-Out (FIFO)
- Elements are stored in order of insertion, but don't have indices.
- Client can only add to the end of the queue, and can only examine/remove the
front of the queue.

- **Main Operations:**
    - **Enqueue:** Add an element to the back of the queue.
    - **Dequeue:** Remove the front element.
    - **Peek:** Examine the front element.

- **Real-World Examples**
    - People on an escalator: first-in, first-out.
    - Cars at a gas station: first-in, first-out.
    - Line of customers waiting for service at a bank.

- **Computer Science Examples**
    - Serving requests on a single shared resource:
        - Printer: queue print jobs to send to the printer
        - CPU Task Scheduling: queue of programs/processes to be run
        - Network: queue of network data packets to send

    - Sophisticated algorithms:
        - Searching in trees, graphs, e.g. BFS, web crawling.

| Operation          | Explanation                                                                                             |
|:-------------------|--------------------------------------------------------------------------------------------------------:|
| enqueue(**value**) | places given value at the back of queue                                                                 |
| dequeue()          | remove value from front of queue and returns it; throws a `NoSuchElementException` if queue is empty    |
| peek()             | returns front value from queue without removing it; throws a `NoSuchElementException` if queue is empty |
| size()             | returns number of elements in queue                                                                     |
| isEmpty()          | returns `true` if queue has no elements                                                                 |

- **Example Usage:**
```cpp
Queue<int> q;
q.enqueue(42);
q.enqueue(-3);
q.enqueue(17);            // front [42, -3, 17] back
std::cout << q.dequeue(); // Output: 42
```

## Queue Processing Styles

As with stacks, we must pull contents out of the queue to view them,
```cpp
while(!q.isEmpty()) {
    // do something with q.dequeue();
}
```
which consequently destroys the queue, but we may actually want that.

Here's another style,
```cpp
int n = q.size();
for(int i = 0; i < n; i++) {
    // do something with q.dequeue();
    // including possibly re-adding it to the queue
}
```
which also destroys it, but, again, we may actually want that. The reason we
use the variable `n` is that the size of the queue may change inside the loop.
If you wrote `for(int i = 0; i < q.size(); i++) { ... }` and then requeued an
item inside the loop with `q.enqueue(item)`, the queue's size would constantly
increase. The call to `q.size()` would never stop growing, leading to an
infinite loop.

## Mixing Stacks and Queues

We often use stacks with queues to achieve some effects. For example, to
reverse the order of the elements of a queue, you can use a stack:
```cpp
Queue<int> q;
q.enqueue(1);
q.enqueue(2);
q.enqueue(3);            // front [1, 2, 3] back

Stack<int> s;
while(!q.isEmpty()) {
    s.push(q.dequeue()); // Q -> S
}
while(!s.isEmpty()) {
    q.enqueue(s.pop());  // S -> Q
}
// Q: front [3, 2, 1] back
```

-------------------------------------------------------------------------------

# Exercises

## Exercise 1 - `stutter()`

Write a member function `stutter` that accepts a queue of integers as a
parameter and replaces every element of the queue with two copies of that
element.
- `front [1, 2, 3] back`, becomes
- `front [1, 1, 2, 2, 3, 3] back`

<details>
    <summary> Solution </summary>

```cpp
```
</details>

## Exercise 2 - `mirror()`

Write a member function `mirror` that accepts a queue of strings as a parameter
and appends the queue's contents to itself in reverse order.
- `front [a, b, c] back` becomes
- `front [a, b, c, c, b, a] back`

<details>
    <summary> Solution </summary>

```cpp
```
</details>

## Exercise 3 - `reverse()`

Write a member function `reverse` that reverses the queue.

<details>
    <summary> Solution </summary>

```cpp
```
</details>

-------------------------------------------------------------------------------

# Stacks vs. Queues

- **Stacks**
    - LIFO
    - `push()` and `pop()` both modify the top element.
    - Computer systems use stacks to manage function calls, including recursive
    function calls.

- **Queues**
    - FIFO
    - `enqueue()` modifies the back element, `dequeue()` modifies the front
    element.
    - Computer systems use queues to manage buffers, printing jobs, etc.

-------------------------------------------------------------------------------

# Searching with Stacks and Queues

Stacks and queues are frequently used in searching problems, such as finding
some or all solutions to a computational problem, often involving constraint
satisfaction problems.

- **Examples:**
    - Eight Queens Puzzle
    - Knight's Tour
    - Sudoku
    - Maze
    - Flood Fill

## The Flood Fill Algorithm

You're given the location of a **seed** pixel, a **target** color, and a
**replacement** color. A color other than the **target** is regarded as
boundary. The algorithm starts with the seed pixel, color it the
**replacement**, then visits its **four neighbors**. If a neighbor's color is
still the **target** color, we replace it with **replacement, and proceed to
visit its neighbors in turn.

### Flood Fill with a Queue

- **Algorithm**
    1. Imagine using a Queue to implement flood fill.
    2. Start at the seed pixel and an empty queue, add all four neighbors to
    the queue.
    3. Dequeue the first element, the right of the seed, add all its neighbors
    to the queue.
    4. Dequeue the second element, the left neighbor of the seed, add all its
    neighbors to the queue.
    5. Proceed until the queue is empty.

- Searching with a **Stack** is often called **Depth-First Search** (**DFS**).
It's often used to find *a* solution as quickly as possible.
- Searching with a **Queue** is called **Breadth-First Search*** (**BFS**).
It's often used to find the **best**, e.g. the shortest path, solution. For
example, the shortest path out of a maze, the shortest distance from the seed
pixel to the boundary, etc.

-------------------------------------------------------------------------------

# Design Decisions

For the following scenario select the appropriate ADT and implementation and
explain why they are optimal for this scenario.

## Scenario

You're writing a program to schedule jobs sent to a laser printer. The laser
printer should process these jobs in the order in which the requests were
received. There are busy and slow times for requests that can have large
differences in the volume of jobs sent to the printer. Which ADT and what
implementation would you use to store the jobs sent to the printer?

- **ADT Options:**
    - List
    - Stack
    - Queue

- **Implementation Options:**
    - Array
    - Linked List

------------------------------------------------------------------------------

# Exercises

## Exercise 1 - `copyStack()`

Write a member function called `copyStack()` that accepts a stack of integers
as a parameter and returns a copy of the original stack. The original stack
must be restored to its original state. **You may use one queue as auxiliary
storage.**

```cpp
Stack<int> copyStack(Stack<int>& s)
```

## Exercise 2 - `expunge()`

Write a member function called `expunge()` that accepts a stack of integers as
a parameter and makes sure that the stack's elements are in non-decreasing
order from top to bottom, by removing any element that is smaller than any
element(s) on top of it from the stack. **You may use one queue or stack (but
not both) as auxiliary storage.**

```cpp
// Given Stack: Bottom [4, 20, 15, 8, 5, 7, 12, 3, 10, 5, 1] Top
// Remove 3, 7, 5, 8, and 4
// Resulting Stack: Bottom [20, 15, 12, 10, 5, 1] Top
void expunge(Stack<int>& s)
```

## Exercise 3 - Queue w/ Stack

Implement the queue operations enqueue and dequeue by using **only two stacks**
and **no other extra variables**. One of the operations should be O(1). Use the
following stack interface.
```cpp
template<class T> class Stack {
private:
    // not shown, you don't need this info to implement this
public:
    Stack();
    void push(const T& item);
    T pop();
    T peek() const;
    bool isEmpty() const;
};
```

## Exercise 4 - `PrintBackwards()`

Using the stack interface, write a <u>recursive</u> C++ function
`PrintBackwards()` which prints the contents of a given stack S in reverse
order. *The function should not declare or use any other stacks.* The function
may modify the contents of the given stack during its execution, but when its
task is finished, the stack should contain the original elements in their
original order.

```cpp
template<class T> void PrintBackwards(Stakc<T>& s) {}
```

------------------------------------------------------------------------------

# Assignments

## Assignment 1 - Circular Linked List

Create a queue using a circular linked list with one external pointer.

<details>
    <summary> Solution </summary>

```cpp
#include "QException.h"
#include "LinkedList.h"

template<class T> Queue {

}
```
</details>

## Assignment 2 - Naive Array

Create a queue using a fixed sized array list.

<details>
    <summary> Solution </summary>

```cpp
#include "QException.h"
const int MAX_QUEUE = 42; // maximum size of queue, arbitrary

template<class T> class Queue {
private:
    T items[MAX_QUEUE];
    int front;
    int back;
    int count;
public:
    Queue(); // default constructor
    bool isEmpty() const;
    void enqueue(const T& item);
    T dequeue();
    T peek() const;
};

template<class T> Queue<T>::Queue(): front(0), back(MAX_QUEUE - 1), count(0) {}
template<class T> bool Queue<T>::isEmpty() const
{
    return this-> count == 0;
}
template<class T> void Queue<T>::enqueue(const T& item)
{
    if(this->count == MAX_QUEUE) {
        std::stringstream errStr;
        errStr << "Error: Queue full on enqueue." << std::endl;
        throw QException(errStr);
    }
    else {
        this->back = (this->back + 1) % MAX_QUEUE;
        this->items[back] = item;
        ++this->count;
    }
}
template<class T> T Queue<T>::dequeue() {
    if(isEmpty()) {
        std::stringstream errStr;
        errStr << "Error: Empty queue, cannot dequeue." << std::endl;
        throw QException(errStr);
    }
    else {
        T val = this->items[this->front];
        this->front = (this->front + 1) % MAX_QUEUE;
        --this->count;
        return val;
    }
}
template<class T> T Queue<T>::peek() const {
    if(isEmpty()) {
        std::stringstream errStr;
        errStr << "Error: Empty queue, cannot peek." << std::endl;
        throw QException(errStr);
    }
    else {
        return this->items[this->front];
    }
}
```
</details>

## Assignment 3 - Circular Array

Create a queue using a circular array.
